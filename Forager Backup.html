<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Forager 1.2</title>
<style>
  :root{--panel-bg:#0f1113;--panel-border:#333;--text:#e6eef2}
  html,body{height:100%;margin:0;background:#040607;color:var(--text);font-family:Inter,Arial,monospace}
  #game{display:block;margin:8px auto;border-radius:6px;box-shadow:0 12px 50px rgba(0,0,0,0.8)}
  canvas{display:block;}
  #ui{position:fixed;right:14px;top:12px;width:360px;z-index:40}
  .panel{background:var(--panel-bg);border:1px solid var(--panel-border);padding:8px;margin-bottom:8px;border-radius:8px}
  .panel h3{margin:0 0 8px 0;font-size:14px}
  .inv-item{padding:6px;margin:6px 0;border-radius:6px;background:rgba(255,255,255,0.02);display:flex;justify-content:space-between;align-items:center}
  .inv-item button{margin-left:6px}
  button{padding:6px;border-radius:6px;background:#222;color:var(--text);border:1px solid #333;cursor:pointer}
  input{padding:6px;border-radius:6px;border:1px solid #333;background:#0b0b0d;color:var(--text);width:100%}
  #hud{position:fixed;left:12px;bottom:12px;z-index:50}
  #hud .stat{background:rgba(0,0,0,0.25);padding:6px;border-radius:6px;margin-bottom:6px}
  .small{font-size:12px;color:#bfc9d1}
  #controls{display:flex;gap:8px;margin-top:8px}
  #controls button{flex:1}
  .equip-btn{background:#143; border-color:#0a3}
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="ui">
  <div class="panel" id="inventoryPanel"><h3>Inventory</h3><div id="invList"></div></div>
  <div class="panel" id="statsPanel"><h3>Stats</h3><div id="statList"></div></div>
  <div class="panel" id="codePanel">
    <h3>Enter Code</h3>
    <input id="codeInput" placeholder="type code..." /><button onclick="redeemCode()" style="margin-top:6px">Redeem</button>
    <div class="small" style="margin-top:6px">Codes: philiplikesmeteors, iamworthyofsuchpower</div>
  </div>
  <div class="panel" id="devPanel" style="display:none">
    <h3>Developer Panel</h3>

    <!-- Weapon section -->
    <select id="weaponSelect" style="width:100%"></select>
    <button onclick="giveWeapon()">Give Weapon</button>

<!-- Boss spawn section -->
<h3>Boss Spawn (Dev)</h3>
<select id="bossSelect" style="width:100%"></select>
<button onclick="spawnBossDevPanel()">Spawn Boss</button>

<script>
window.addEventListener("DOMContentLoaded", () => {

    const bossSelect = document.getElementById("bossSelect");

    function waitForBossDefs() {
        if (typeof bossDefs === "undefined") {
            setTimeout(waitForBossDefs, 100);
            return;
        }
        populateBossDropdown();
    }

    function populateBossDropdown() {
        bossSelect.innerHTML = ""; // clear existing
        bossDefs.forEach(b => {
            const opt = document.createElement("option");
            opt.value = b.name;
            opt.textContent = b.name;
            bossSelect.appendChild(opt);
        });
    }

    waitForBossDefs();

    // Spawn boss near player (permanent until defeated)
    window.spawnBossDevPanel = function() {
        const selected = bossSelect.value;
        const def = bossDefs.find(b => b.name === selected);
        if (!def) return;

        bosses.push({
            x: player.x + rand(-50,50),
            y: player.y + rand(-50,50),
            w: 56,
            h: 56,
            hp: def.maxHp,
            maxHp: def.maxHp,
            name: def.name,
            rarity: def.rarity,
            biome: def.biome,
            color: def.color,
            dead: false,
            friendly: false, // hostile to player
            attackCooldown: rand(120,420),
            temporary: true // optional, can keep if you want special effects
        });

        if (typeof playSound === "function") playSound("magic");
    };
});
</script>

<div id="hud">
  <div class="stat" id="hpStat"></div>
  <div class="stat" id="currencyStat"></div>
  <div id="controls" style="margin-top:6px">
    <button id="attackBtn">Attack</button>
    <button id="abilityBtn">Ability</button>
  </div>
  <!-- Boss timer -->
  <div id="bossTimerContainer" style="width:300px; height:20px; border:1px solid #fff; margin-top:5px; background:#222;">
    <div id="bossTimerBar" style="width:0%; height:100%; background:#f00;"></div>
  </div>
  <div id="bossCountdown"></div>
  <div id="bossTimerHUD" style="position: absolute; bottom: 100px; left: 20px; width: 200px;">
    <div id="bossCountdown" style="text-align:center; font-weight:bold; margin-bottom: 2px; color:white;"></div>
        <div id="bossBar" style="height: 100%; width: 100%; background: #0f0;"></div>
    </div>
</div>
</div>

<div id="inventoryPanel" style="background:#555; width:300px; height:auto;">
    <div id="invList"></div>
</div>

<script>
/* =========================
   RPG Final â€” Camera + Shadow + Full Features
   - Player visible & camera follows across supersized grids
   - Player shadow rendered beneath player sprite
   - WASD movement, inventory, stats, enchants, bosses, meteors, chests
   - Attack & Ability UI buttons and Equip option in inventory
   ========================= */
   
   function updateBossTimer(){
  const rem = Math.max(0, BOSS_SAFE_MS - (nowMs() - START_MS));
  const percent = Math.min(100, (rem / BOSS_SAFE_MS) * 100);
  
  // update bar
  const bar = document.getElementById('bossTimerBar');
  if(bar) bar.style.width = percent + '%';

  // update text
  const countdown = document.getElementById('bossCountdown');
  if(countdown){
    countdown.innerText = rem > 0 
      ? `Bosses allowed in: ${Math.floor(rem/60000)}:${Math.floor((rem%60000)/1000).toString().padStart(2,'0')}`
      : 'Bosses: ENABLED';
  }
}

/* ---------- Canvas & DPI ---------- */
const CSS_W = 1200, CSS_H = 760;
const DPR = Math.min(window.devicePixelRatio || 1, 2);
const canvas = document.getElementById('game');
canvas.width = Math.round(CSS_W * DPR);
canvas.height = Math.round(CSS_H * DPR);
canvas.style.width = CSS_W + 'px';
canvas.style.height = CSS_H + 'px';
const ctx = canvas.getContext('2d');
ctx.scale(DPR, DPR);

/* ---------- Tunables ---------- */
const GRID_TILE_COUNT = 240;     // very large grid
const TILE_SIZE = 10;           // px per tile
const GRID_PX = GRID_TILE_COUNT * TILE_SIZE;
const WORLD_SEED = Math.floor(Math.random()*1e9);
const PARTICLE_COUNT = 30;

/* ---------- Utilities ---------- */
function rand(a,b){ return a + Math.random()*(b-a); }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function nowMs(){ return Date.now(); }
function norm(dx,dy){ const d=Math.hypot(dx,dy)||1; return {x:dx/d,y:dy/d}; }

/* ---------- Player & Stats ---------- */
const player = {
    x: 0,
    y: 0,
    w: 26,
    h: 26,
    color: '#7fe77f',
    baseSpeed: 3,
    speed: 3,
    hp: 100,
    maxHp: 500,
    inventory: [],
    equipped: null,
    stats: { power: 0, durability: 0, stealth: 0, speed: 0 },
    statPoints: 20,
    coins: 100,
    gems: 0,
    coinEnchantLevel: 0,
    gemEnchantLevel: 0,
    
    // Cooldowns in milliseconds
    attackCooldown: 0,
    abilityCooldown: 0,
    
    // Leveling
    level: 1,
    xp: 0,
    xpToNext: 100,

    // Gain XP method
    gainXP: function(amount) {
        this.xp += amount;

        while (this.xp >= this.xpToNext) {
            this.xp -= this.xpToNext;
            this.level++;
            this.statPoints += 5; // Points per level
            this.xpToNext = Math.floor(this.xpToNext * 1.5); // Increase XP required by 1.5x

            // Optionally: heal player on level up
            this.hp = this.maxHp;

            // Optional: show level-up VFX and sound
            burst(this.x + this.w / 2, this.y + this.h / 2, '255,255,100', 60);
            playSound('levelup');
        }
    }
};

/* ---------- Biomes ---------- */
const BIOME_WEIGHTS = [
  {name:'grass', weight:75, color:'#b6f0b6', ground:'#81c781'},
  {name:'desert', weight:15, color:'#f2e1b6', ground:'#d5bf85'},
  {name:'snow', weight:8, color:'#eef6ff', ground:'#dbeefc'},
  {name:'volcano', weight:2, color:'#6a1a12', ground:'#5a0f0f'},
  {name:'fungal', weight:1, color:'#c9a0e6', ground:'#8f53a4'}
];
function chooseBiomeFromR(r){ let acc=0; for(const b of BIOME_WEIGHTS){ acc+=b.weight; if(r*100 < acc) return b;} return BIOME_WEIGHTS[0]; }
const worldGrid = {};
function getGridBiome(gx, gy){
  const key = gx + ',' + gy;
  if(worldGrid[key]) return worldGrid[key];

  const biomeScale = 0.01; // adjust this for bigger or smaller biomes
  const pseudo = Math.abs(Math.sin(gx * 127.1 * biomeScale + gy * 311.7 * biomeScale + WORLD_SEED)) % 1;

  const b = chooseBiomeFromR(pseudo);
  worldGrid[key] = b;
  return b;
}

/* ---------- Smart Player Spawn in Grassland ---------- */
function spawnPlayerInGrassArea() {
    const maxAttempts = 1000; // safety cap
    let attempts = 0;
    while (attempts < maxAttempts) {
        const gx = Math.floor(Math.random() * GRID_TILE_COUNT);
        const gy = Math.floor(Math.random() * GRID_TILE_COUNT);
        const biome = getGridBiome(gx, gy);
        if (biome.name === 'grass') {
            player.x = gx * TILE_SIZE + TILE_SIZE / 2;
            player.y = gy * TILE_SIZE + TILE_SIZE / 2;
            return;
        }
        attempts++;
    }
    // fallback if grass not found (should be rare)
    player.x = GRID_TILE_COUNT/2 * TILE_SIZE;
    player.y = GRID_TILE_COUNT/2 * TILE_SIZE;
}
// Call this after defining 'player' and before the game loop
spawnPlayerInGrassArea();

/* ---------- Camera ---------- */
const camera = { x: player.x - CSS_W/2 + player.w/2, y: player.y - CSS_H/2 + player.h/2, lerp: 0.12 };

/* ---------- Input ---------- */
const keys = {}; window.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false);

const mouse = { x:CSS_W/2, y:CSS_H/2, worldX:player.x, worldY:player.y };
canvas.addEventListener('mousemove', e=>{ const r=canvas.getBoundingClientRect(); mouse.x = e.clientX - r.left; mouse.y = e.clientY - r.top; mouse.worldX = mouse.x + camera.x; mouse.worldY = mouse.y + camera.y; });

/* ---------- Particles & Effects ---------- */
let particles = [];
function spawnParticle(x,y,opts={}){ particles.push({ x,y, vx:(Math.random()-0.5)*(opts.spread||2), vy:(Math.random()-0.5)*(opts.spread||2), color:opts.color||'255,255,255', size:opts.size||2, life:Math.floor(rand(opts.lifeMin||20, opts.lifeMax||60)) }); }
function burst(x,y,color,count=PARTICLE_COUNT){ for(let i=0;i<count;i++) spawnParticle(x,y,{color,spread:4,lifeMin:12,lifeMax:80,size:1+Math.random()*2}); }
function updateParticles(){ for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.life--; p.size *= 0.995; if(p.life<=0) particles.splice(i,1); } }
function drawParticles(ctx){ for(const p of particles){ ctx.fillStyle = `rgba(${p.color},${Math.max(0,p.life/60)})`; ctx.fillRect(p.x - camera.x, p.y - camera.y, p.size, p.size); } }

/* ---------- Projectiles & VFX ---------- */
let projectiles = [], vfxs = [];
function spawnProjectile(x,y,vx,vy,opts={}){ projectiles.push(Object.assign({ x,y,vx,vy, r:opts.r||4, life:opts.life||200, damage:opts.damage||10, color:opts.color||'255,200,80', source:opts.source||'unknown', type:opts.type||'bolt', weapon:opts.weapon||null }, {})); }
function spawnVFX(type,x,y,opts={}){ vfxs.push(Object.assign({ type,x,y,color:opts.color||'255,255,255',size:opts.size||6,life:opts.life||30,weapon:opts.weapon||null }, {})); }
function updateProjectilesAndVFX(){
  for(let i=projectiles.length-1;i>=0;i--){ const p=projectiles[i]; p.x+=p.vx; p.y+=p.vy; p.life--; spawnParticle(p.x,p.y,{color:p.color,spread:0.6,lifeMin:6,lifeMax:20,size:1}); if(p.life<=0) projectiles.splice(i,1); }
  for(let i=vfxs.length-1;i>=0;i--){ vfxs[i].life--; if(vfxs[i].life<=0) vfxs.splice(i,1); }
}
function drawVFX(ctx){
  for(const v of vfxs){
    const alpha = clamp(v.life/40,0,1);
    switch(v.type){
      case 'hit': ctx.fillStyle = `rgba(${v.color},${alpha})`; ctx.fillRect(v.x-camera.x - v.size/2, v.y-camera.y - v.size/2, v.size, v.size); break;
      case 'arc': ctx.fillStyle = `rgba(${v.color},${alpha})`; ctx.beginPath(); ctx.arc(v.x-camera.x, v.y-camera.y, v.size*(1+v.life/30), 0, Math.PI*2); ctx.fill(); break;
      case 'beam': ctx.fillStyle = `rgba(${v.color},${alpha})`; ctx.fillRect(v.x-camera.x-3, 0, 6, CSS_H); break;
      case 'cosmic': ctx.fillStyle = `rgba(${v.color},${alpha})`; ctx.beginPath(); ctx.arc(v.x-camera.x, v.y-camera.y, v.size*4*(v.life/30),0,Math.PI*2); ctx.fill(); break;
      default: ctx.fillStyle = `rgba(${v.color},${alpha})`; ctx.fillRect(v.x-camera.x-2, v.y-camera.y-2, 4,4); break;
    }
  }
  for(const p of projectiles){ ctx.fillStyle = `rgba(${p.color},1)`; ctx.beginPath(); ctx.arc(p.x-camera.x, p.y-camera.y, p.r, 0, Math.PI*2); ctx.fill(); }
}

/* ---------- Sounds ---------- */
const sounds = {};
function loadSound(k,u){ try{ const a = new Audio(u); a.preload='auto'; sounds[k]=a; }catch(e){} }
function playSound(k){ try{ if(sounds[k]){ const s = sounds[k].cloneNode(); s.play(); } }catch(e){} }
loadSound('swing','https://cdn.jsdelivr.net/gh/zeroasterisk/sfx-placeholders/swing.mp3');
loadSound('magic','https://cdn.jsdelivr.net/gh/zeroasterisk/sfx-placeholders/magic.mp3');
loadSound('arrow','https://cdn.jsdelivr.net/gh/zeroasterisk/sfx-placeholders/arrow.mp3');
loadSound('explosion','https://cdn.jsdelivr.net/gh/zeroasterisk/sfx-placeholders/explosion.mp3');
loadSound('chest','https://cdn.jsdelivr.net/gh/zeroasterisk/sfx-placeholders/chest.mp3');
loadSound('pickup','https://cdn.jsdelivr.net/gh/zeroasterisk/sfx-placeholders/pickup.mp3');
loadSound('vamp','https://cdn.jsdelivr.net/gh/zeroasterisk/sfx-placeholders/vamp.mp3');

/* ---------- Weapon Catalog ---------- */
const weaponCatalog = [
  {name:"Broken Sword",rarity:"common",type:"melee"},
  {name:"Rusty Battle Axe",rarity:"common",type:"hammer"},
  {name:"Mana Deficient Spell Book",rarity:"common",type:"magic"},
  {name:"Old Magic Staff",rarity:"common",type:"magic"},
  {name:"Old Bow",rarity:"common",type:"bow"},
  {name:"Withered Chakram",rarity:"common",type:"chakram"},
  {name:"Iron Hammer",rarity:"rare",type:"hammer"},
  {name:"Iron Sword",rarity:"rare",type:"melee"},
  {name:"Sharpened Chakram",rarity:"rare",type:"chakram"},
  {name:"Spell Book",rarity:"rare",type:"magic"},
  {name:"Crossbow",rarity:"rare",type:"bow"},
  {name:"Magic Imbued Staff",rarity:"rare",type:"magic"},
  {name:"Flamethrower",rarity:"epic",type:"flame"},
  {name:"Refined Chakram",rarity:"epic",type:"chakram"},
  {name:"Elemental Sword",rarity:"epic",type:"elemental"},
  {name:"Paladin's Hammer",rarity:"legendary",type:"paladin"},
  {name:"Bomb-O-Launcher",rarity:"legendary",type:"bomb"},
  {name:"Daybreaker",rarity:"legendary",type:"daybreaker"},
  {name:"Crescent Mask",rarity:"mythic",type:"crescent"},
  {name:"Cryogenic",rarity:"mythic",type:"ice"},
  {name:"Soul Reaper", rarity:"mythic", type:"soulReaper"},
  {name:"Shockwave Hammer",rarity:"exotic",type:"shockwave"},
  {name:"Vampirism",rarity:"exotic",type:"vampiric"},
  {name:"Mimicry",rarity:"exotic",type:"cone"},
  {name:"End Of Time",rarity:"galactic",type:"wipe"},
  {name:"Fracture Of The Cosmos",rarity:"cosmic",type:"fracture"},
  {name:"Queen's Hand", rarity:"cosmic", type:"queensHand"},
  {name:"King Philip's Sword Of Calamity",rarity:"developer",type:"calamity"},
];
function createWeapon(tpl){ return { name: tpl.name, rarity: tpl.rarity, type: tpl.type, atk: Math.round(8*(1 + ({common:0,rare:1,epic:2,legendary:4,mythic:8,exotic:10,universal:20,multiversal:50}[tpl.rarity]||0))), shiny: Math.random()<0.07, enchants: [] }; }

/* ---------- Inventory UI (with Equip) ---------- */
const invList = document.getElementById('invList');
function updateInventoryUI(){
  invList.innerHTML = '';
  for(const it of player.inventory){
    const div = document.createElement('div'); div.className='inv-item';
    const label = document.createElement('div'); label.textContent = it.name + (it.shiny ? ' âœ¨' : '') + ` [${it.rarity}]`;
    const btns = document.createElement('div');
    const equipBtn = document.createElement('button'); equipBtn.textContent = (player.equipped === it ? 'Equipped' : 'Equip'); equipBtn.className='equip-btn';
    equipBtn.onclick = ()=>{ player.equipped = it; playSound('pickup'); updateInventoryUI(); updateHUD(); };
    const enchantBtn = document.createElement('button'); enchantBtn.textContent='Enchant'; enchantBtn.onclick = ()=>{ const ch = prompt('type coin or gem'); if(ch==='coin') enchantWithCoins(it); else if(ch==='gem') enchantWithGems(it); };
    btns.appendChild(equipBtn); btns.appendChild(enchantBtn);
    div.appendChild(label); div.appendChild(btns);
    invList.appendChild(div);
  }
}

/* ---------- Inventory Toggle ---------- */
function toggleInventory() {
    // Replace 'invList' with the correct parent div if you have one
    const inv = document.getElementById('invList');
    if (!inv) return;

    inv.style.display = (inv.style.display === 'none' || inv.style.display === '') ? 'block' : 'none';
}

window.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'i') {
        toggleInventory();
    }
});


/* ---------- Stats UI ---------- */
const statList = document.getElementById('statList');
function updateStatsUI(){
  statList.innerHTML = `Points: ${player.statPoints}<br/>`;
  ['power','durability','stealth','speed'].forEach(s=>{
    const row = document.createElement('div');
    row.innerHTML = `${s}: ${player.stats[s]} <button onclick="addStat('${s}')">+</button> <button onclick="removeStat('${s}')">-</button>`;
    statList.appendChild(row);
  });
}
function addStat(s){
  const caps = { power:10, durability:10, stealth:3, speed:5 };
  if(player.statPoints > 0 && player.stats[s] < (caps[s] || 99)){ player.stats[s]++; player.statPoints--; applyStatEffects(); updateStatsUI(); updateHUD(); }
}
function removeStat(s){ if(player.stats[s] > 0){ player.stats[s]--; player.statPoints++; applyStatEffects(); updateStatsUI(); updateHUD(); } }
function applyStatEffects(){ player.maxHp = 100 + player.stats.durability * 5; player.hp = Math.min(player.hp, player.maxHp); player.speed = player.baseSpeed * (1 + (player.stats.speed / 5) * 0.5); }

/* ---------- Enchanting ---------- */
function enchantWithCoins(item){
  const cost = 100 + player.coinEnchantLevel*50;
  if(player.coins < cost){ alert('Not enough coins'); return; }
  player.coins -= cost; player.coinEnchantLevel++;
  const success = Math.random() < 0.7;
  if(success){ item.enchants.push('CoinEnchant'); if(Math.random()<0.15) item.shiny=true; burst(player.x,player.y,'255,220,80',24); playSound('magic'); }
  else { burst(player.x,player.y,'120,120,120',16); playSound('explosion'); }
  updateHUD(); updateInventoryUI();
}
function enchantWithGems(item){
  const cost = 5 + player.gemEnchantLevel*2;
  if(player.gems < cost){ alert('Not enough gems'); return; }
  player.gems -= cost; player.gemEnchantLevel++;
  item.enchants.push('GemEnchant'); item.shiny = true; burst(player.x,player.y,'0,255,255',36); playSound('magic');
  updateHUD(); updateInventoryUI();
}

/* ---------- Chests & Meteors & Villages ---------- */
let chests = [], meteors = [], villages = [];
function spawnChestAt(x,y){
  const rarities = ['rare','epic','legendary','mythic','exotic','universal','multiversal'];
  const probs = [0.5,0.2,0.15,0.08,0.05,0.015,0.005];
  let r=Math.random(),acc=0,choose='rare';
  for(let i=0;i<rarities.length;i++){ acc+=probs[i]; if(r<acc){ choose=rarities[i]; break; } }
  const pool = weaponCatalog.filter(w=>w.rarity===choose);
  const tpl = pool.length? pick(pool) : pick(weaponCatalog);
  const wep = createWeapon(tpl); wep.enchants.push('GuaranteedChest');
  chests.push({x,y,opened:false,contents:{coins:Math.floor(rand(40,140)),gems:Math.random()<0.22?1:0,weapon:wep}});
}
for(let i=0;i<5;i++) spawnChestAt(rand(120,CSS_W-120), rand(120,CSS_H-120));
function spawnMeteor() {
    // Only spawn if no meteors exist
    if (meteors.length > 0) return;

    const r = Math.random() * 100;
    let rarity = 'legendary';

    // Nerfed rarity chances
    if (r < 0.5) rarity = 'multiversal';
    else if (r < 5) rarity = 'universal';
    else if (r < 20) rarity = 'exotic';
    else if (r < 30) rarity = 'mythic';
    else rarity = 'legendary';

    const pool = weaponCatalog.filter(w => w.rarity === rarity);
    const tpl = pool.length ? pick(pool) : pick(weaponCatalog);
    const wep = createWeapon(tpl);
    wep.enchants.push('FromMeteor');

    meteors.push({
        x: rand(120, CSS_W - 120),
        y: -40,
        vy: rand(3, 7),
        landed: false,
        weapon: wep
    });
}

// Still less frequent: spawn attempt every 90 seconds
setInterval(spawnMeteor, 90000);
for(let i=0;i<4;i++) villages.push({x:rand(120,CSS_W-120), y:rand(120,CSS_H-120), w:36, h:36});
canvas.addEventListener('click', (e)=>{
  const r=canvas.getBoundingClientRect(); const wx = e.clientX - r.left + camera.x, wy = e.clientY - r.top + camera.y;
  for(const c of chests){ if(!c.opened && Math.hypot(c.x - wx, c.y - wy) < 36){ c.opened = true; player.coins += c.contents.coins; player.gems += c.contents.gems; player.inventory.push(c.contents.weapon); burst(c.x,c.y,'255,230,160',40); playSound('chest'); updateInventoryUI(); updateHUD(); return; } }
  for(const v of villages){ if(Math.abs(wx - v.x) < v.w && Math.abs(wy - v.y) < v.h){ const buy = confirm('Merchant: Buy health potion for 120 coins?'); if(buy && player.coins>=120){ player.coins-=120; player.hp = Math.min(player.maxHp, player.hp+70); playSound('pickup'); updateHUD(); } return; } }
});

/* ---------- Enemies & Bosses ---------- */
const bossDefs = [
  {name:"Desert Scourge", biome:"desert", rarity:"common", maxHp:1000, color:"#d4b17a"},
  {name:"Lava Golem", biome:"volcano", rarity:"common", maxHp:2500, color:"#ff6b3b"},
  {name:"Cryo Manipulator", biome:"snow", rarity:"rare", maxHp:5000, color:"#73e7ff"},
  {name:"Molten Dragon", biome:"volcano", rarity:"epic", maxHp:10000, color:"#ff8a33"},
  {name:"Duke Goblindor", biome:"grass", rarity:"legendary", maxHp:50000, color:"#2ecc71"},
  {name:"Pharoah's Curse", biome:"desert", rarity:"mythic", maxHp:100000, color:"#ffd86b"},
  {name:"Fungal Mushinator", biome:"fungal", rarity:"exotic", maxHp:250000, color:"#b66fff"},
  {name:"Moon Goddess", biome:"grass", rarity:"exotic", maxHp:5000000, color:"#a0d8ff"},
  {name:"The Queen Of Calamity", biome:"grass", rarity:"universal", maxHp:50000000, color:"#111111"},
  {name:"King Philip, God Over Everything", biome:"grass", rarity:"multiversal", maxHp:100000000, color:"#2b2bff"}
];
const bossSpawnChances = { common:0.20, rare:0.10, epic:0.05, legendary:0.03, mythic:0.01, exotic:0.005, universal:0.002, multiversal:0.0005 };

let enemies = []; function spawnEnemy(x,y){ enemies.push({x,y,w:18,h:18,hp:30,maxHp:30,atk:5,color:'#f44',dead:false}); }
for(let i=0;i<6;i++) spawnEnemy(rand(120,CSS_W-120), rand(120,CSS_H-120));
let bosses = []; function spawnBoss(def){ const b={x:rand(160,CSS_W-160), y:rand(160,CSS_H-160), w:56, h:56, hp:def.maxHp, maxHp:def.maxHp, name:def.name, rarity:def.rarity, biome:def.biome, color:def.color, dead:false, attackCooldown:rand(120,420)}; bosses.push(b); burst(b.x,b.y,'255,0,255',160); playSound('explosion'); }

/* ---------- Boss safe period & behaviors ---------- */
const START_MS = nowMs(); const BOSS_SAFE_MS = 10*60*1000;
function bossAllowed(){ return (nowMs() - START_MS) >= BOSS_SAFE_MS; }
function bossDash(b){ const d=norm(player.x - b.x, player.y - b.y); b.x += d.x*200; b.y += d.y*200; burst(b.x,b.y,'255,60,60',26); playSound('explosion'); if(Math.hypot(player.x-b.x,player.y-b.y) < 48) player.hp -= 9; }
function bossShoot(b){ for(let i=0;i<3;i++){ const aimx=player.x+rand(-40,40), aimy=player.y+rand(-40,40); const v=norm(aimx-b.x,aimy-b.y); spawnProjectile(b.x,b.y,v.x*6,v.y*6,{r:5,damage:25,color:'255,120,20',source:'boss'}); } playSound('arrow'); }
function bossAoe(b,r){ burst(b.x,b.y,'255,120,20',120); if(Math.hypot(player.x-b.x,player.y-b.y) < r) player.hp -= 18; playSound('explosion'); }
function bossTeleport(b){ b.x = rand(160,CSS_W-160); b.y = rand(160,CSS_H-160); burst(b.x,b.y,'255,255,80',90); if(Math.hypot(player.x-b.x,player.y-b.y) < 140) player.hp -= 25; playSound('explosion'); }
function bossMassiveGrid(b){ burst(CSS_W/2,CSS_H/2,'200,50,255',200); player.hp -= 30; playSound('explosion'); }
function bossUltimate(b){ burst(b.x,b.y,'255,255,255',400); player.hp -= 120; playSound('explosion'); }

/* ---------- Enemy spawner helpers (WORLD-SPAWN VERSION) ---------- */
let _spawnAccumulator = 0;
const MIN_ENEMIES = 50;
const MAX_ENEMIES = 150;
const SPAWN_CHECK_INTERVAL = 1000;

// huge world scatter range
const WORLD_SPAWN_RANGE = 30000; 
const SAFE_DISTANCE_FROM_PLAYER = 1000; // enemies NEVER spawn within this range

// enemy detection distance (SMALL â€” player must see them to aggro)
const DETECTION_RANGE = 250;

// safe fallback enemy list
const _enemyTypesSafe = (typeof enemyTypes !== 'undefined' && Array.isArray(enemyTypes) && enemyTypes.length)
  ? enemyTypes
  : [
      { type: 'sprinter', color:'#3b9cff', hp:75, speed:2.5, xp:15 },
      { type: 'ranger', color:'#a020f0', hp:150, speed:1.8, xp:20 },
      { type: 'heavy', color:'#8b0000', hp:400, speed:0.9, xp:25 },
      { type: 'knight', color:'#808080', hp:250, speed:1.5, xp:35 },
      { type: 'megaKnight', color:'#333333', hp:650, speed:0.7, xp:50 },
      { type: 'necromancer', color:'#4b0082', hp:250, speed:1.5, xp:60 }
    ];

/** spawnEnemyWorldScatter()
 *  Spawns enemies FAR AWAY across the infinite world,
 *  NOT around the player.
 */
function spawnEnemyWorldScatter() {
  if (typeof enemies === 'undefined') window.enemies = [];

  const pool = _enemyTypesSafe.filter(t => !t.summoned);
  if (!pool.length) return;

  const tpl = pool[Math.floor(Math.random() * pool.length)];

  let sx, sy;
  do {
    // randomly place anywhere in a huge world range
    sx = player.x + (Math.random() * WORLD_SPAWN_RANGE - WORLD_SPAWN_RANGE/2);
    sy = player.y + (Math.random() * WORLD_SPAWN_RANGE - WORLD_SPAWN_RANGE/2);

    // reject if too close to player
  } while (Math.hypot(sx - player.x, sy - player.y) < SAFE_DISTANCE_FROM_PLAYER);

  enemies.push({
    type: tpl.type,
    color: tpl.color,
    hp: tpl.hp,
    maxHp: tpl.hp,
    speed: tpl.speed,
    xp: tpl.xp,
    summoned: !!tpl.summoned,
    dead: false,
    x: sx,
    y: sy,
    w: tpl.w || 20,
    h: tpl.h || 20,
    weapon: tpl.weapon || null,

    // ðŸ”¥ NEW â†’ detection behavior
    detectionRange: DETECTION_RANGE,
    chasing: false
  });
}

/** spawnEnemies(dt)
 *  Keeps enemy count in the world between MIN and MAX.
 */
function spawnEnemies(dt) {
  _spawnAccumulator += dt;
  if (_spawnAccumulator < SPAWN_CHECK_INTERVAL) return;
  _spawnAccumulator = 0;

  const aliveCount = enemies.filter(e => !e.dead).length;

  if (aliveCount >= MAX_ENEMIES) return;

  const need = Math.max(0, Math.min(MIN_ENEMIES - aliveCount, MAX_ENEMIES - aliveCount));

  for (let i = 0; i < need; i++) {
    spawnEnemyWorldScatter();
  }
}


/* ---------- Update entities (enemies & bosses) with leveling ---------- */
function updateEntities(dt){
    const detectMultiplier = 1 - (player.stats.stealth * 0.18);

    // --- ENEMIES ---
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];

        if (e.dead) {
            enemies.splice(i, 1);
            continue;
        }

        // ============================
        //     FRIENDLY ZOMBIE AI
        // ============================
        if (e.friendly) {
            const detectionRange = 225;

            // Find nearest non-friendly enemy
            let nearest = null;
            let nearestDist = Infinity;
            for (const t of enemies) {
                if (!t.friendly && !t.dead) {
                    const dx = t.x - e.x;
                    const dy = t.y - e.y;
                    const dist = Math.hypot(dx, dy);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearest = t;
                    }
                }
            }
            e.target = nearest;

            // Move toward target if within detection range
            if (e.target && nearestDist <= detectionRange) {
                const dx = e.target.x - e.x;
                const dy = e.target.y - e.y;
                const d = Math.hypot(dx, dy) || 1;

                e.x += (dx / d) * e.speed;
                e.y += (dy / d) * e.speed;

            // Deal 70 damage on contact and zombie dies
            if (d < 30 && e.target && !e.target.dead) {
             // Damage enemy
              const damage = Math.min(50, e.target.hp); // deal max 50, never go negative
              e.target.hp -= damage;
              spawnVFX('hit', e.target.x, e.target.y, { color: '50,200,50' });
              if (typeof playSound === "function") playSound('hit');

    // Zombie dies after attack
    e.dead = true;
    burst(e.x, e.y, '50,200,50', 24);
}
            }

            continue; // Skip normal enemy AI
        }

        // ============================
        //     NORMAL ENEMY AI
        // ============================
        const dx = player.x - e.x;
        const dy = player.y - e.y;
        const d = Math.hypot(dx, dy) || 1;

        // Move toward player
        e.x += (dx / d) * (e.speed || 0.6);
        e.y += (dy / d) * (e.speed || 0.6);

        // Attack player if close
        if(d < 26){
            player.hp -= 0.25;
            spawnVFX('hit', player.x, player.y, {color:'255,60,60'});
        }

        // ======================================================
        // NECROMANCER â€” SUMMON ZOMBIES
        // ======================================================
        if (e.type === 'necromancer' && !e.summonedZombies) {
            const rarityTable = [
                { name: "Common",    weight: 55, hp: 50,  speed: 1.9, size: 12, scale: 0.55 },
                { name: "Uncommon",  weight: 20, hp: 75,  speed: 2.0, size: 13, scale: 0.60 },
                { name: "Rare",      weight: 12, hp: 110, speed: 2.1, size: 14, scale: 0.65 },
                { name: "Epic",      weight: 8,  hp: 150, speed: 2.25,size: 15, scale: 0.70 },
                { name: "Legendary", weight: 5,  hp: 200, speed: 2.4, size: 16, scale: 0.75 }
            ];

            function pickRarity() {
                let total = rarityTable.reduce((a, r) => a + r.weight, 0);
                let roll = Math.random() * total;
                for (let r of rarityTable) {
                    if (roll < r.weight) return r;
                    roll -= r.weight;
                }
                return rarityTable[0];
            }

            const specialTable = [
                { type: "normal",     weight: 50,  color: "#006400" },
                { type: "runner",     weight: 15,  color: "#1aff00", speedBoost: 1.3 },
                { type: "tank",       weight: 10,  color: "#556b2f", hpBoost: 2.0, sizeBoost: 1.4 },
                { type: "exploder",   weight: 5,   color: "#ff4500", explodes: true },
                { type: "spitter",    weight: 5,   color: "#39ff14", ranged: true },
                { type: "ghost",      weight: 4,   color: "#8ef6ff", ghost: true },
                { type: "frost",      weight: 3,   color: "#00cfff", slowEffect: true },
                { type: "fire",       weight: 3,   color: "#ff9d00", burnEffect: true },
                { type: "poison",     weight: 3,   color: "#32cd32", poisonEffect: true },
                { type: "arcane",     weight: 2,   color: "#bf00ff", magicShield: true },
                { type: "brute",      weight: 1,   color: "#ffd700", hpBoost: 4.0, sizeBoost: 1.8, elite: true }
            ];

            function pickSpecial() {
                let total = specialTable.reduce((a, s) => a + s.weight, 0);
                let roll = Math.random() * total;
                for (let s of specialTable) {
                    if (roll < s.weight) return s;
                    roll -= s.weight;
                }
                return specialTable[0];
            }

            for (let j = 0; j < 4; j++) {
                const R = pickRarity();
                const S = pickSpecial();

                let hp = R.hp;
                let spd = R.speed;
                let size = R.size;
                let scale = R.scale;
                let color = S.color;

                if (S.hpBoost) hp *= S.hpBoost;
                if (S.speedBoost) spd *= S.speedBoost;
                if (S.sizeBoost) size *= S.sizeBoost;
                if (S.sizeBoost) scale *= S.sizeBoost * 0.9;

                enemies.push({
                    type: "zombie",
                    friendly: true,
                    rarity: R.name,
                    variant: S.type,
                    hp: hp,
                    maxHp: hp,
                    speed: spd,
                    color: color,
                    w: size,
                    h: size,
                    scale: scale,
                    explodes: S.explodes || false,
                    ranged: S.ranged || false,
                    ghost: S.ghost || false,
                    slowEffect: S.slowEffect || false,
                    burnEffect: S.burnEffect || false,
                    poisonEffect: S.poisonEffect || false,
                    magicShield: S.magicShield || false,
                    elite: S.elite || false,
                    summoned: true,
                    dead: false,
                    weapon: null,
                    x: e.x + rand(-30, 30),
                    y: e.y + rand(-30, 30)
                });
            }

            e.summonedZombies = true;
        }

        // ---------------------------
        //  DEATH HANDLING
        // ---------------------------
        if(e.hp <= 0 && !e.dead){
            e.hp = 0;
            e.dead = true;
            burst(e.x, e.y, '255,255,255', 100);
            if(typeof playSound === "function") playSound('explosion');
            player.statPoints += 1;
            player.coins += Math.max(5, Math.round(e.maxHp * 0.1));

            const xpGained = e.maxHp * 0.5;
            player.xp += xpGained;
            while(player.xp >= player.xpToNext){
                player.xp -= player.xpToNext;
                player.level += 1;
                player.statPoints += 1;
                player.xpToNext = Math.floor(player.xpToNext * 1.5);
                if(typeof playSound === "function") playSound('levelup');
                burst(player.x, player.y, '255,215,0', 80);
            }
        }
    }
}

    // --- BOSSES ---
    for (const b of bosses) {
        if (b.dead) continue;

        // Boss cooldowns & attacks
        b.attackCooldown -= dt;
        if (b.attackCooldown <= 0){
            switch(b.rarity){
                case 'common': bossDash(b); b.attackCooldown = rand(2200,2400); break;
                case 'rare': bossShoot(b); b.attackCooldown = rand(600,800); break;
                case 'epic': bossAoe(b,100); b.attackCooldown = rand(5000,7000); break;
                case 'legendary': 
                    bossAoe(b,120); 
                    for(let i=0;i<3;i++) spawnEnemy(b.x+rand(-40,40), b.y+rand(-40,40)); 
                    b.attackCooldown = rand(8000,9000); 
                    break;
                case 'mythic': bossAoe(b,160); setTimeout(()=>bossAoe(b,120),300); b.attackCooldown = rand(10000,12000); break;
                case 'exotic': bossTeleport(b); bossAoe(b,140); b.attackCooldown = rand(3200,4800); break;
                case 'universal': bossMassiveGrid(b); b.attackCooldown = rand(15000,25000); break;
                case 'multiversal': bossUltimate(b); b.attackCooldown = rand(30000,50000); break;
                default: bossDash(b); b.attackCooldown = rand(8000,1000);
            }
        }

        // Boss movement toward player
        const dx = player.x - b.x;
        const dy = player.y - b.y;
        const d = Math.hypot(dx, dy) || 1;
        b.x += (dx / d) * 0.2;
        b.y += (dy / d) * 0.2;

        // Boss death handling
        if(b.hp <= 0 && !b.dead){
            b.hp = 0;
            b.dead = true;
            burst(b.x,b.y,'255,255,255',300);
            if(typeof playSound === "function") playSound('explosion');
            player.statPoints += 1;
            player.coins += Math.max(200, Math.round(b.maxHp * 0.001));
            player.gems += (b.rarity==='mythic'||b.rarity==='exotic')?2:1;
            spawnChestAt(b.x-12,b.y-12);
			
			// ============================
    //  FRIENDLY QUEEN'S HAND AI
    // ============================
    if (b.friendly) {
        // Find nearest enemy if no target or target dead
        if (!b.target || b.target.dead) {
            b.target = enemies.find(e => !e.friendly && !e.dead);
        }

        if (b.target) {
            const dx = b.target.x - b.x;
            const dy = b.target.y - b.y;
            const dist = Math.hypot(dx, dy) || 1;

            // Only move if within detection range (e.g., 67)
            if (dist < 67) {
                b.x += (dx / dist) * (b.speed || 1.5); // adjust speed
                b.y += (dy / dist) * (b.speed || 1.5);
            }

            // Deal damage on contact
            if (dist < 40) { // contact radius
                b.target.hp -= 70; // nerfed damage
                spawnVFX('hit', b.target.x, b.target.y, { color: '255,180,0' });
                if (typeof playSound === "function") playSound('hit');
            }
        }

        continue; // Skip normal boss AI
    }

    // --- Normal boss behavior below ---
    // (existing AI code for non-friendly bosses)
}
        }

    // Spawn enemies to maintain 100-250 count around player
    const targetEnemies = 150;
    if(enemies.length < targetEnemies){
        for(let s=0; s < targetEnemies - enemies.length; s++){
        function spawnEnemyNearPlayer() {
    const types = [
        { type:'sprinter', color:'#00f', hp:50, speed:2.5, xp:15, weapon:null },
        { type:'ranger', color:'#800080', hp:80, speed:1.5, xp:20, weapon:'bow' },
        { type:'heavy', color:'#8b0000', hp:400, speed:0.4, xp:25, weapon:null },
        { type:'knight', color:'#808080', hp:250, speed:1, xp:35, weapon:'iron_sword' },
        { type:'mega_knight', color:'#444', hp:650, speed:0.3, xp:50, weapon:'bomb_launcher' },
        { type:'necromancer', color:'#4b0082', hp:250, speed:1, xp:40, weapon:null },
    ];
    const t = types[Math.floor(Math.random()*types.length)];
    const angle = Math.random()*Math.PI*2;
    const dist = 400 + Math.random()*400; // spawn 400-800 px away
    const x = player.x + Math.cos(angle)*dist;
    const y = player.y + Math.sin(angle)*dist;

    enemies.push({
        type: t.type,
        color: t.color,
        hp: t.hp,
        maxHp: t.hp,
        speed: t.speed,
        weapon: t.weapon,
        x, y
    });
}

			
        }
    }

  // Bosses
  for(const b of bosses){
    if(b.dead) continue;

    b.attackCooldown -= dt;
    if(b.attackCooldown <= 0){
      switch(b.rarity){
        case 'common': bossDash(b); b.attackCooldown = rand(2200,2400); break;
        case 'rare': bossShoot(b); b.attackCooldown = rand(600,800); break;
        case 'epic': bossAoe(b,100); b.attackCooldown = rand(5000,7000); break;
        case 'legendary': bossAoe(b,120); for(let i=0;i<3;i++) spawnEnemy(b.x+rand(-40,40), b.y+rand(-40,40)); b.attackCooldown = rand(8000,9000); break;
        case 'mythic': bossAoe(b,160); setTimeout(()=>bossAoe(b,120),300); b.attackCooldown = rand(10000,12000); break;
        case 'exotic': bossTeleport(b); bossAoe(b,140); b.attackCooldown = rand(3200,4800); break;
        case 'universal': bossMassiveGrid(b); b.attackCooldown = rand(15000,25000); break;
        case 'multiversal': bossUltimate(b); b.attackCooldown = rand(30000,50000); break;
        default: bossDash(b); b.attackCooldown = rand(800,1000);
      }
    }

    const dx = player.x - b.x, dy = player.y - b.y, d = Math.hypot(dx,dy)||1;
    b.x += (dx/d)*0.2; b.y += (dy/d)*0.2;

    // Boss death
    if(b.hp <= 0 && !b.dead){ 
      b.hp = 0;
      b.dead = true;
      burst(b.x,b.y,'255,255,255',300); 
      playSound('explosion'); 
      player.statPoints += 1; 
      player.coins += Math.max(200, Math.round(b.maxHp*0.001)); 
      player.gems += (b.rarity==='mythic'||b.rarity==='exotic')?2:1; 
      spawnChestAt(b.x-12,b.y-12); 
    }
  }

/* ---------- Damage helper ---------- */
function hitEntitiesInRadius(x,y,radius,damage,weapon,onDamage){
  for(const e of enemies){ if(e.dead) continue; if(Math.hypot(e.x-x,e.y-y) <= radius){ e.hp -= damage; if(onDamage) onDamage(damage); burst(e.x,e.y,'255,80,60',20); spawnVFX('hit', e.x, e.y, {color:rarityToColor(weapon.rarity)}); if(e.hp <= 0){ e.dead = true; burst(e.x,e.y,'255,160,40',36); } } }
  for(const b of bosses){ if(b.dead) continue; if(Math.hypot(b.x-x,b.y-y) <= radius){ b.hp -= damage; burst(b.x,b.y,'255,200,80',40); spawnVFX('hit', b.x, b.y, {color:rarityToColor(weapon.rarity)}); if(b.hp <= 0){ b.dead = true; burst(b.x,b.y,'255,255,255',160); player.coins += Math.max(300, Math.round(b.maxHp*0.001)); player.gems += (b.rarity==='exotic'||b.rarity==='mythic')?2:1; player.statPoints += 1; spawnChestAt(b.x-12,b.y-12); } } }
}

/* ---------- Weapon visuals & attacks ---------- */
function rarityToColor(r){
  switch(r){ case 'common': return '180,180,180'; case 'rare': return '60,140,255'; case 'epic': return '180,80,255'; case 'legendary': return '255,200,60'; case 'mythic': return '255,90,90'; case 'exotic': return '60,240,220'; case 'universal': return '10,10,10'; case 'multiversal': return '220,220,255'; default: return '255,255,255'; }
}

function performAttack() {
    // --- Check cooldown first ---
    if (player.attackCooldown > 0) return;

    const w = player.equipped; 
    if(!w) { 
        burst(player.x, player.y, '255,255,255', 8); 
        return; 
    }

    const base = w.atk * (1 + 0.2 * player.stats.power);

    switch(w.type) {

        case 'melee':
        case 'elemental': {
            const dx = mouse.worldX - player.x;
            const dy = mouse.worldY - player.y;
            const len = Math.hypot(dx, dy) || 1;

            const offsetX = (dx / len) * 20;
            const offsetY = (dy / len) * 20;

            spawnVFX('arc', player.x + offsetX + ((dx>0)?10:-10), player.y + offsetY, {
                color: rarityToColor(w.rarity),
                size: 14,
                life: 24
            });

            hitEntitiesInRadius(player.x + offsetX, player.y + offsetY, 56, base, w);
            playSound('swing');
            break;
        }

        case 'hammer': {
            spawnVFX('arc', player.x, player.y + 6, {
                color: rarityToColor(w.rarity),
                size: 20,
                life: 30
            });
            hitEntitiesInRadius(player.x, player.y + 6, 72, base * 1.2, w);
            playSound('explosion');
            break;
        }

        case 'paladin': {
            spawnVFX('arc', player.x, player.y + 6, {
                color: rarityToColor(w.rarity),
                size: 40,
                life: 75
            });
            hitEntitiesInRadius(player.x, player.y + 6, 144, base * 2.4, w);
            playSound('explosion');
            break;
        }

        case 'chakram': {
            const d = norm(mouse.worldX - player.x, mouse.worldY - player.y);
            spawnProjectile(player.x, player.y, d.x * 10, d.y * 10, {
                r: 5,
                damage: base,
                color: rarityToColor(w.rarity),
                source: 'player',
                weapon: w,
                type: 'chakram'
            });
            playSound('arrow');
            break;
        }

        case 'bow':
        case 'projectile': {
            const dd = norm(mouse.worldX - player.x, mouse.worldY - player.y);
            spawnProjectile(player.x, player.y, dd.x * 11, dd.y * 11, {
                r: 4,
                damage: base,
                color: rarityToColor(w.rarity),
                source: 'player',
                weapon: w
            });
            playSound('arrow');
            break;
        }

        case 'magic':
        case 'flame': {
            for(let i = 0; i < 3; i++) {
                const a = Math.atan2(mouse.worldY - player.y, mouse.worldX - player.x) + rand(-0.2, 0.2);
                spawnProjectile(player.x + Math.cos(a)*10, player.y + Math.sin(a)*10, Math.cos(a)*7, Math.sin(a)*7, {
                    r: 6,
                    damage: base * 1.1,
                    color: rarityToColor(w.rarity),
                    source: 'player',
                    weapon: w
                });
            }
            playSound('magic');
            break;
        }

        case 'bomb': {
            const d2 = norm(mouse.worldX - player.x, mouse.worldY - player.y);
            spawnProjectile(player.x, player.y, d2.x * 4, d2.y * 4, {
                r: 6,
                life: 140,
                color: '255,60,40',
                damage: 0,
                source: 'player',
                type: 'bomb',
                weapon: w,
                onHit: (target) => {
                    if (!target || target.dead) return;
                    let ticks = 6, tick = 0;
                    const interval = setInterval(() => {
                        if (!target || target.dead || tick >= ticks) {
                            clearInterval(interval);
                            return;
                        }
                        target.hp -= w.atk * 0.2;
                        tick++;
                    }, 500);
                }
            });
            playSound('explosion');
            break;
        }

        case 'vampiric': {
            hitEntitiesInRadius(player.x, player.y, 48, base, w, (dmg) => {
                const heal = Math.min(player.maxHp - player.hp, dmg * 0.35);
                player.hp += heal;
                burst(player.x, player.y, '255,0,120', 18);
            });
            playSound('vamp');
            break;
        }

        case 'calamity': {
            const dx = mouse.worldX - player.x;
            const dy = mouse.worldY - player.y;
            const len = Math.hypot(dx, dy) || 1;

            const offsetX = (dx / len) * 200;
            const offsetY = (dy / len) * 200;

            spawnVFX('cosmic', player.x + offsetX, player.y + offsetY, {
                color: '255,40,40',
                size: 40,
                life: 36
            });
            hitEntitiesInRadius(player.x + offsetX, player.y + offsetY, 350, w.atk*750000, w);
            playSound('explosion');
            break;
        }

        case 'daybreaker': {
            const dir = norm(mouse.worldX - player.x, mouse.worldY - player.y);
            const proj = spawnProjectile(player.x, player.y, dir.x * 12, dir.y * 12, {
                r: 6,
                damage: 0,
                color: rarityToColor(w.rarity),
                source: 'player',
                weapon: w,
                type: 'daybreaker',
                cling: false,
                clingTarget: null
            });
            proj.onHit = (target) => {
                if (!target || target.dead) return;
                proj.vx = 0;
                proj.vy = 0;
                proj.cling = true;
                proj.clingTarget = target;

                let ticks = 8, tick = 0;
                const interval = setInterval(() => {
                    if (!target || target.dead || tick >= ticks) {
                        clearInterval(interval);
                        burst(proj.x, proj.y, '255,150,0', 100);
                        const idx = projectiles.indexOf(proj);
                        if (idx !== -1) projectiles.splice(idx,1);
                        return;
                    }
                    target.hp -= w.atk * 0.25;
                    spawnParticle(target.x, target.y, { color:'255,220,50', size:2, lifeMin:10, lifeMax:20, spread:1 });
                    tick++;
                }, 500);
            };
            break;
        }
		
		case 'soulReaper': {
    // Attack: melee arc with stronger damage
    const dx = mouse.worldX - player.x;
    const dy = mouse.worldY - player.y;
    const len = Math.hypot(dx, dy) || 1;
    const offsetX = (dx / len) * 20;
    const offsetY = (dy / len) * 20;

    spawnVFX('arc', player.x + offsetX, player.y + offsetY, { color: rarityToColor(w.rarity), size:24, life:36 });
    hitEntitiesInRadius(player.x + offsetX, player.y + offsetY, 64, w.atk*2, w);
    playSound('swing');
    break;
}

case 'queensHand': {
    const dx = mouse.worldX - player.x;
    const dy = mouse.worldY - player.y;
    const dir = norm(dx, dy);

    spawnProjectile(player.x, player.y, dir.x * 4, dir.y * 4, {
        r: 30,
        life: 160,
        damage: base * 5,
        color: '255,0,255',
        source: 'player',
        type: 'queensHandAttack',
		pierce: true,
        hitList: new Set(),
        weapon: w,
        onHit: (target, projectile) => {
            spawnVFX('explosion', projectile.x, projectile.y, {
                color: '255,0,255',
                size: 60,
                life: 40
            });
            hitEntitiesInRadius(projectile.x, projectile.y, 110, base * 3, w);
        }
    });

    playSound('magic');
    break;
}

case 'cone': { // Mimicry
    const dx = mouse.worldX - player.x;
    const dy = mouse.worldY - player.y;
    const len = Math.hypot(dx, dy) || 1;

    // Offset to spawn VFX slightly in front of player
    const offsetX = (dx / len) * 20;
    const offsetY = (dy / len) * 20;

    // Spawn arc VFX with visible size and life
    spawnVFX('arc', player.x + offsetX, player.y + offsetY, {
        color: rarityToColor(w.rarity),
        size: 40, // bigger size for visibility
        life: 60   // longer life to see the slash
    });

    // Hit entities in a radius in front of the player
    hitEntitiesInRadius(player.x + offsetX, player.y + offsetY, 80, w.atk * 2, w);

    playSound('swing');
    break;
}

        default: {
            hitEntitiesInRadius(player.x, player.y, 40, base, w);
            playSound('swing');
            break;
        }
    }

    // --- Small hit particles
    burst(player.x + rand(-8,8), player.y + rand(-8,8), rarityToColor(w.rarity), 6);

    // --- Set attack cooldown (0.5s)
    player.attackCooldown = 500;
}

/* ---------- Abilities ---------- */
function performAbility(){
  if(player.abilityCooldown > 0) return; // cooldown check
  player.abilityCooldown = 7000; // 10 seconds

  const w = player.equipped;
  if(!w){ burst(player.x, player.y, '255,255,255', 8); return; }
  switch(w.type){
    case 'paladin': {
    // Same visual effect as attack
    spawnVFX('arc', player.x, player.y + 6, {
        color: rarityToColor(w.rarity),
        size: 55,
        life: 120
    });

    // Bigger radius for ability
    hitEntitiesInRadius(player.x, player.y + 6, 288, w.atk * 12 * (1 + 0.2 * player.stats.power), w);

    playSound('explosion');
    break;
}

    case 'bomb':
      const d = norm(mouse.worldX-player.x, mouse.worldY-player.y);
      spawnProjectile(player.x, player.y, d.x*6, d.y*6, {r:10, life:120, damage:0, color:'255,90,40', source:'player', type:'giantBomb', weapon:w});
      playSound('explosion');
      break;
	  
    case 'daybreaker': { // Ability version
    const dir = norm(mouse.worldX - player.x, mouse.worldY - player.y);

    const proj = spawnProjectile(player.x, player.y, dir.x * 8, dir.y * 8, {
        r: 12,
        damage: 0,
        color: '255,215,60',
        source: 'player',
        weapon: w,
        type: 'daybreaker',
        cling: false, // mark when it clings
        onHit: (target, projectile) => {
            if (!target || target.dead) return;

            // Make it cling
            projectile.vx = 0;
            projectile.vy = 0;
            projectile.cling = true; 
            projectile.clingTarget = target;

            const duration = 4000; // 4 seconds
            const tickInterval = 250;
            let elapsed = 0;

            const clingInterval = setInterval(() => {
                if (!projectile.clingTarget || projectile.clingTarget.dead || elapsed >= duration) {
                    clearInterval(clingInterval);

                    // Final explosion
                    spawnVFX('explosion', projectile.x, projectile.y, {color: '255,100,0', size: 60, life: 40});
                    hitEntitiesInRadius(projectile.x, projectile.y, 100, w.atk * 2, w);
                    playSound('explosion');

                    // Remove projectile
                    const idx = projectiles.indexOf(projectile);
                    if (idx !== -1) projectiles.splice(idx, 1);
                    return;
                }

                // Keep projectile visually on enemy
                projectile.x = projectile.clingTarget.x;
                projectile.y = projectile.clingTarget.y;

                // DoT damage
                projectile.clingTarget.hp -= w.atk * 0.25;

                // Optional VFX while clinging
                spawnParticle(projectile.x, projectile.y, { color: '255,215,60', size: 3, lifeMin: 10, lifeMax: 20, spread: 1 });

                elapsed += tickInterval;
            }, tickInterval);
        }
    });

    playSound('magic');
    break;
}

    case 'flame':
      for(let i=0;i<18;i++){
        const ang = Math.atan2(mouse.worldY-player.y, mouse.worldX-player.x) + rand(-0.6,0.6);
        spawnProjectile(player.x+Math.cos(ang)*10, player.y+Math.sin(ang)*10, Math.cos(ang)*6, Math.sin(ang)*6, {r:4, damage:w.atk*0.8, color:'255,100,30', source:'player', weapon:w});
      }
      playSound('magic');
      break;

    case 'vampiric':
      hitEntitiesInRadius(player.x, player.y, 70, w.atk*2, w, (dmg)=>{ const heal = Math.min(player.maxHp-player.hp, dmg*0.5); player.hp += heal; burst(player.x,player.y,'255,0,120',28); });
      break;

    case 'chakram':
      for(let i=0;i<3;i++){
        const ang = Math.atan2(mouse.worldY-player.y, mouse.worldX-player.x) + (i-1)*0.4;
        spawnProjectile(player.x, player.y, Math.cos(ang)*9, Math.sin(ang)*9, {r:5, damage:w.atk*1.2, color:rarityToColor(w.rarity), source:'player', weapon:w});
      }
      playSound('arrow');
      break;

    case 'calamity':
      spawnVFX('cosmic', player.x, player.y, {color:'255,255,255', size:80, life:80});
      hitEntitiesInRadius(player.x, player.y, 500, w.atk*10000000, w);
      playSound('explosion');
      break;
	  
case 'soulReaper': {
    // --- Ability: summon 4 friendly zombies ---
    for (let i = 0; i < 4; i++) {
        const xOffset = rand(-30, 30);
        const yOffset = rand(-30, 30);

        enemies.push({
            type: 'zombie',
            friendly: true,           // marks as player ally
            rarity: 'Common',
            variant: 'normal',
            hp: 100,
            maxHp: 100,
            speed: 1.9,
            color: '#006400',
            w: 12,
            h: 12,
            scale: 0.6,
            summoned: true,
            dead: false,
            weapon: null,
            x: player.x + xOffset,
            y: player.y + yOffset
        });
    }

    // Summon sound
    playSound('summon');
    break;
}

case 'queensHand': {
    const def = bossDefs[randInt(0, bossDefs.length - 1)];
    const b = {
        x: player.x + rand(-50, 50),
        y: player.y + rand(-50, 50),
        w: 56, h: 56,
        hp: def.maxHp,
        maxHp: def.maxHp,
        name: def.name,
        rarity: def.rarity,
        biome: def.biome,
        color: def.color,
        dead: false,
        attackCooldown: rand(120, 420),
        temporary: true,
        lifetime: 7000,
        friendly: true, // <-- mark as friendly
        target: null     // <-- will find nearest enemy in update loop
    };
    bosses.push(b);
    playSound('magic');
    break;
}

case 'cone': { // Mimicry Ability
    const dx = mouse.worldX - player.x;
    const dy = mouse.worldY - player.y;
    const len = Math.hypot(dx, dy) || 1;

    const offsetX = (dx / len) * 40;
    const offsetY = (dy / len) * 40;

    // Bigger VFX for ability
    spawnVFX('arc', player.x + offsetX, player.y + offsetY, {
        color: rarityToColor(w.rarity),
        size: 80,
        life: 80
    });

    hitEntitiesInRadius(player.x + offsetX, player.y + offsetY, 140, w.atk * 4, w);

    playSound('powerSlash');
    break;
}

    default:
      hitEntitiesInRadius(player.x, player.y, 60, w.atk*1.5, w);
      playSound('swing');
      break;
	  
  }
}

/* ---------- Keybindings ---------- */
window.addEventListener('keydown', (e) => {
    const key = e.key.toLowerCase();

    // Attack: Spacebar
    if (key === ' ' || key === 'spacebar') {
        performAttack();
        e.preventDefault(); // prevent scrolling
    }

    // Ability: E
    if (key === 'e') {
        performAbility();
    }
});

/* ---------- Projectile collisions ---------- */
function handleProjectileCollisions(){
  for(let i=projectiles.length-1;i>=0;i--){
    const p = projectiles[i];
    if(p.source === 'player'){
      let removed=false;
      for(const e of enemies){ if(e.dead) continue; if(Math.hypot(e.x - p.x, e.y - p.y) < e.w/2 + p.r){ e.hp -= p.damage; burst(e.x,e.y,'255,120,80',18); spawnVFX('hit', e.x, e.y, {color:p.color}); projectiles.splice(i,1); removed=true; break; } }
      if(removed) continue;
      for(const b of bosses){ if(b.dead) continue; if(Math.hypot(b.x - p.x, b.y - p.y) < b.w/2 + p.r){ b.hp -= p.damage; burst(b.x,b.y,'255,200,80',30); spawnVFX('hit', b.x, b.y, {color:p.color}); projectiles.splice(i,1); removed=true; break; } }
      if(removed) continue;
    } else {
      // boss projectiles hitting player
      if(Math.hypot(p.x - player.x, p.y - player.y) < p.r + 12){ player.hp -= p.damage; burst(player.x,player.y,'255,80,40',22); projectiles.splice(i,1); continue; }
    }
  }
}

function updateProjectiles(){
  for(let i=projectiles.length-1;i>=0;i--){
    const p = projectiles[i];

    // ===== Move projectile =====
    if(p.cling && p.clingTarget && !p.clingTarget.dead){
      // Follow the target if clinging
      p.x = p.clingTarget.x;
      p.y = p.clingTarget.y;
    } else {
      p.x += p.vx;
      p.y += p.vy;
    }

    p.life--;
    spawnParticle(p.x, p.y, {color:p.color, spread:0.6, lifeMin:6, lifeMax:18, size:1});

    // ===== Bomb explode =====
    if(p.type === 'bomb' && p.life <= 0){
      burst(p.x,p.y,'255,80,40',200); playSound('explosion');
      for(const e of enemies) if(!e.dead && Math.hypot(e.x - p.x, e.y - p.y) < 80) e.hp -= 80;
      for(const b of bosses) if(!b.dead && Math.hypot(b.x - p.x, b.y - p.y) < 120) b.hp -= Math.max(500, b.maxHp*0.01);
      projectiles.splice(i,1); continue;
    }

    if(p.type === 'giantBomb' && p.life <= 0){
      burst(p.x,p.y,'255,100,40',300); playSound('explosion');
      for(const e of enemies) if(!e.dead && Math.hypot(e.x - p.x, e.y - p.y) < 140) e.hp -= 180;
      for(const b of bosses) if(!b.dead && Math.hypot(b.x - p.x, b.y - p.y) < 220) b.hp -= Math.max(1500, b.maxHp*0.02);
      projectiles.splice(i,1); continue;
    }

    // Remove projectile if life ended and not already handled
    if(p.life <= 0) projectiles.splice(i,1);
  }
}

/* ---------- World draw ---------- */
function drawWorld(){
  const pgx = Math.floor(player.x / GRID_PX), pgy = Math.floor(player.y / GRID_PX);
  for(let gy = pgy - 1; gy <= pgy + 1; gy++){
    for(let gx = pgx - 1; gx <= pgx + 1; gx++){
      const b = getGridBiome(gx,gy);
      const x = gx * GRID_PX - camera.x, y = gy * GRID_PX - camera.y;
      ctx.fillStyle = b.ground; ctx.fillRect(x,y,GRID_PX,GRID_PX);
      // subtle tile shading
      ctx.save(); ctx.globalAlpha = 0.08; ctx.fillStyle = 'black';
      for(let ty=0; ty<GRID_TILE_COUNT; ty+=6){
        for(let tx=0; tx<GRID_TILE_COUNT; tx+=6){
          ctx.fillRect(x + tx*TILE_SIZE + ((tx%12===0)?1:0), y + ty*TILE_SIZE, TILE_SIZE-1, TILE_SIZE-1);
        }
      }
      ctx.restore();
      // vignette
      const g = ctx.createLinearGradient(x,y,x+GRID_PX,y+GRID_PX); g.addColorStop(0,'rgba(0,0,0,0.03)'); g.addColorStop(1,'rgba(0,0,0,0.07)'); ctx.fillStyle = g; ctx.fillRect(x,y,GRID_PX,GRID_PX);
      // decorations
      ctx.save(); ctx.translate(x,y); ctx.globalAlpha = 0.9;
      if(b.name === 'grass'){ for(let i=0;i<18;i++){ ctx.fillStyle='#1b5a1b'; ctx.fillRect(rand(12,GRID_PX-12), rand(12,GRID_PX-12), 2,6); } }
      else if(b.name === 'desert'){ for(let i=0;i<10;i++){ ctx.fillStyle='#b07b40'; ctx.fillRect(rand(12,GRID_PX-12), rand(12,GRID_PX-12), 6,6); } }
      else if(b.name === 'snow'){ for(let i=0;i<12;i++){ ctx.fillStyle='#cfeeff'; ctx.fillRect(rand(12,GRID_PX-12), rand(12,GRID_PX-12), 4,4); } }
      else if(b.name === 'fungal'){ for(let i=0;i<10;i++){ ctx.fillStyle='#9b4fb2'; ctx.beginPath(); ctx.arc(rand(12,GRID_PX-12), rand(12,GRID_PX-12), 6,0,Math.PI*2); ctx.fill(); } }
      else if(b.name === 'volcano'){ for(let i=0;i<6;i++){ ctx.fillStyle='#bb2b18'; ctx.fillRect(rand(12,GRID_PX-12), rand(12,GRID_PX-12), 8,8); } }
      ctx.restore();
    }
  }
}

/* ---------- Draw statics, entities, player (with shadow) ---------- */
function drawStatics(){
  for(const v of villages){ ctx.fillStyle='#6b3b1f'; ctx.fillRect(v.x-camera.x - v.w/2, v.y-camera.y - v.h/2, v.w, v.h); ctx.fillStyle='#3a220f'; ctx.fillRect(v.x-camera.x - v.w/4, v.y-camera.y - v.h/2 - 6, v.w/2, 4); }
  for(const c of chests){ if(!c.opened){ ctx.fillStyle='#8b4513'; ctx.fillRect(c.x-camera.x, c.y-camera.y, 20, 20); } else { ctx.fillStyle='rgba(120,120,120,0.12)'; ctx.fillRect(c.x-camera.x, c.y-camera.y, 20, 20); } }
  for(const m of meteors){ if(!m.landed){ ctx.fillStyle='#a04fbf'; ctx.beginPath(); ctx.arc(m.x-camera.x, m.y-camera.y, 8,0,Math.PI*2); ctx.fill(); } else { ctx.fillStyle='#452214'; ctx.beginPath(); ctx.arc(m.x-camera.x, m.y-camera.y, 18,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#7d2fbf'; ctx.fillRect(m.x-camera.x-4, m.y-camera.y-4, 8,8); } }
}

function drawEntities(){
  for(const e of enemies){ if(e.dead) continue; ctx.fillStyle = e.color; ctx.fillRect(e.x-camera.x - e.w/2, e.y-camera.y - e.h/2, e.w, e.h); ctx.fillStyle='red'; ctx.fillRect(e.x-camera.x - 9, e.y-camera.y - e.h/2 - 8, 18*(e.hp/e.maxHp), 4); }
  let topBoss = null;
  for(const b of bosses){ if(b.dead) continue; ctx.fillStyle=b.color; ctx.fillRect(b.x-camera.x - b.w/2, b.y-camera.y - b.h/2, b.w, b.h); ctx.fillStyle='black'; ctx.fillRect(b.x-camera.x - 30, b.y-camera.y - b.h/2 - 20, 60, 12); ctx.fillStyle='lime'; ctx.fillRect(b.x-camera.x - 30, b.y-camera.y - b.h/2 - 20, 60*clamp(b.hp/b.maxHp,0,1), 12); ctx.fillStyle='white'; ctx.font='11px monospace'; ctx.fillText(`${Math.floor(b.hp)}/${b.maxHp}`, b.x-camera.x - 14, b.y-camera.y - b.h/2 - 7); if(!topBoss) topBoss=b; }
  if(topBoss) drawBossOverlay(topBoss);
}

function drawBossOverlay(b){
  ctx.save();
  const w=480,h=28,x=CSS_W/2-w/2,y=28;
  ctx.fillStyle='white'; ctx.font='18px monospace'; ctx.fillText(b.name, CSS_W/2 - ctx.measureText(b.name).width/2, y-6);
  ctx.fillStyle='#333'; ctx.fillRect(x,y,w,h);
  ctx.fillStyle='#ff4d4d'; ctx.fillRect(x,y,w*clamp(b.hp/b.maxHp,0,1),h);
  ctx.fillStyle='#fff'; ctx.font='14px monospace'; ctx.fillText(`${Math.floor(b.hp)}/${b.maxHp}`, CSS_W/2 - ctx.measureText(`${Math.floor(b.hp)}/${b.maxHp}`).width/2, y+h-6);
  ctx.restore();
}

/* draw player with subtle shadow */
function drawPlayer(){
  // shadow
  const sx = player.x - camera.x;
  const sy = player.y - camera.y + player.h/2 + 6;
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.beginPath();
  ctx.ellipse(sx + player.w/2 - player.w/2, sy, player.w*0.9, player.h*0.35, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
  // player sprite
  ctx.fillStyle = player.color; ctx.fillRect(player.x - camera.x - player.w/2, player.y - camera.y - player.h/2, player.w, player.h);
  // equipment glow / hand
  if(player.equipped){ ctx.fillStyle = `rgba(${rarityToColor(player.equipped.rarity)},0.9)`; ctx.fillRect(player.x - camera.x + 8, player.y - camera.y - 6, 8, 8); }
}

/* ---------- World updates: meteors, grid transition & boss spawn ---------- */
let prevGridKey = null;
function worldUpdate(dt){
  // ---------- Meteors (Cinematic) ----------
  for(const m of meteors){
    if(!m.landed){
      m.y += m.vy;

      // Meteor trail
      spawnParticle(m.x, m.y, {
        color: '180,0,255',
        spread: 3,
        lifeMin: 20,
        lifeMax: 40,
        size: 3
      });

      // Impact check
      if(m.y > CSS_H * 0.8){
        m.landed = true;

        // Explosion with big crater
        burst(m.x, m.y, '160,70,200', m.craterSize);
        playSound('explosion');

        // Chest at impact
        spawnChestAt(m.x-12, m.y-12);
      }

      // Optional visual meteor (ellipse)
      ctx.fillStyle = '#aa33ff';
      ctx.beginPath();
      ctx.ellipse(m.x, m.y, m.width, m.height, 0, 0, Math.PI*2);
      ctx.fill();
    }
  }

  // ---------- Boss spawn & grid transition (unchanged) ----------
  const pg = { gx: Math.floor(player.x / GRID_PX), gy: Math.floor(player.y / GRID_PX) };
  const key = pg.gx + ',' + pg.gy;
  if(key !== prevGridKey){
    prevGridKey = key;
    if(bossAllowed()){
      const biome = getGridBiome(pg.gx, pg.gy).name;
      for(const def of bossDefs){
        if(def.biome === biome || def.biome === 'any'){
          const chance = bossSpawnChances[def.rarity] || 0;
          if(Math.random() < chance){
            spawnBoss(def);
            break;
          }
        }
      }
    }
  }
}

/* ---------- HUD update ---------- */
function updateHUD(){
  document.getElementById('hpStat').innerHTML = `HP: ${Math.max(0, Math.floor(player.hp))}/${player.maxHp}`;
  document.getElementById('currencyStat').innerHTML = `Coins: ${player.coins} â€¢ Gems: ${player.gems} â€¢ Equipped: ${player.equipped ? player.equipped.name : 'None'}`;
}


/* ---------- start inventory & dev panel ---------- */
(function starter(){ player.inventory.push(createWeapon(weaponCatalog.find(w=>w.rarity==='common'))); player.inventory.push(createWeapon(weaponCatalog.find(w=>w.rarity==='rare'))); updateInventoryUI(); updateStatsUI(); updateHUD(); populateDevPanel(); })();
function populateDevPanel(){ const sel=document.getElementById('weaponSelect'); sel.innerHTML=''; for(const w of weaponCatalog){ const o=document.createElement('option'); o.value=w.name; o.textContent=`${w.name} (${w.rarity})`; sel.appendChild(o); } }
function redeemCode(){ const c=document.getElementById('codeInput').value.trim(); if(c==='philiplikesmeteors'){ const tpl = weaponCatalog.find(w=>w.name==="King Philip's Sword Of Calamity"); player.inventory.push(createWeapon(tpl)); updateInventoryUI(); alert('Redeemed King Philip!'); } else if(c==='iamworthyofsuchpower'){ document.getElementById('devPanel').style.display='block'; populateDevPanel(); } else alert('Invalid code'); }
function giveWeapon(){ const name=document.getElementById('weaponSelect').value; const tpl=weaponCatalog.find(w=>w.name===name); player.inventory.push(createWeapon(tpl)); updateInventoryUI(); }

/* ---------- click attack handling via UI buttons ---------- */
document.getElementById('attackBtn').addEventListener('click', ()=> performAttack());
document.getElementById('abilityBtn').addEventListener('click', ()=> performAbility());

/* ---------- chests spawn helper ---------- */
function spawnChestAt(x,y){ const rarities = ['rare','epic','legendary','mythic','conqueror','galactic','cosmic']; const probs=[0.5,0.2,0.15,0.08,0.05,0.015,0.005]; let r=Math.random(),acc=0,choose='rare'; for(let i=0;i<rarities.length;i++){ acc+=probs[i]; if(r<acc){ choose=rarities[i]; break; } } const pool = weaponCatalog.filter(w=>w.rarity===choose); const tpl = pool.length? pick(pool) : pick(weaponCatalog); const wep = createWeapon(tpl); wep.enchants.push('GuaranteedChest'); chests.push({x,y,opened:false,contents:{coins:Math.floor(rand(40,140)),gems:Math.random()<0.22?1:0,weapon:wep}}); }

/* ---------- click interactions for chests & villages (already added) ---------- */

// === INITIALIZE UI ===
updateInventoryUI();
updateStatsUI();
updateHUD();
applyStatEffects();


/* ---------- main game loop ---------- */
let last = performance.now();
function loop(now){
  const dt = Math.max(16, now - last);
  last = now;

  // movement
  let mx = 0, my = 0;
  if (keys['w'] || keys['arrowup']) my -= 1;
  if (keys['s'] || keys['arrowdown']) my += 1;
  if (keys['a'] || keys['arrowleft']) mx -= 1;
  if (keys['d'] || keys['arrowright']) mx += 1;

  if (mx !== 0 || my !== 0){
    const len = Math.hypot(mx, my) || 1;
    mx /= len;
    my /= len;
    player.x += mx * player.speed;
    player.y += my * player.speed;
  }

  // camera smoothing
  camera.x += ((player.x - CSS_W/2 + player.w/2) - camera.x) * camera.lerp;
  camera.y += ((player.y - CSS_H/2 + player.h/2) - camera.y) * camera.lerp;

  camera.x = Math.max(0, camera.x);
  camera.y = Math.max(0, camera.y);

  // updates
  updateParticles();
  updateProjectilesAndVFX();
  updateProjectiles();
  handleProjectileCollisions();
  updateEntities(dt);
  worldUpdate(dt);
  spawnEnemies(dt);
  
  // ----- UPDATE PLAYER COOLDOWNS -----
  if(player.attackCooldown > 0) player.attackCooldown -= dt;
  if(player.abilityCooldown > 0) player.abilityCooldown -= dt;

  // ----- SAFE UI UPDATES -----
  if (typeof updateBossTimer === "function") updateBossTimer();
  if (typeof updateHUD === "function") updateHUD();
  // ----------------------------

  // draw
  ctx.clearRect(0,0,CSS_W,CSS_H);

  const pg = {
    gx: Math.floor(player.x / GRID_PX),
    gy: Math.floor(player.y / GRID_PX)
  };
  const base = getGridBiome(pg.gx, pg.gy);
  ctx.fillStyle = base?.color || "#071017";
  ctx.fillRect(0,0,CSS_W,CSS_H);

  drawWorld();
  drawStatics();
  drawEntities();
  drawVFX(ctx);
  drawParticles(ctx);
  drawPlayer();

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);




/* ---------- debug exposure ---------- */
window._GAME = { player, enemies, bosses, chests, meteors };

/* ---------- End of file ---------- */

</script>
</body>
</html>


